:mod:`suite2p.register`
=======================

.. py:module:: suite2p.register


Module Contents
---------------

.. data:: eps0
   :annotation: = 1e-05

   

.. data:: sigL
   :annotation: = 0.85

   

.. data:: hp
   :annotation: = 60

   

.. function:: gaussian_fft(sig, Ly, Lx)

   gaussian filter in the fft domain with std sig and size Ly,Lx


.. function:: spatial_taper(sig, Ly, Lx)

   spatial taper  on edges with gaussian of std sig


.. function:: spatial_smooth(data, N)

   spatially smooth data using cumsum over axis=1,2 with window N


.. function:: spatial_high_pass(data, N)

   high pass filters data over axis=1,2 with window N


.. function:: one_photon_preprocess(data, ops)

   pre filtering for one-photon data


.. function:: prepare_masks(refImg0, ops)

   computes masks and fft'ed reference image for phasecorr

   :param refImg0: reference image
   :type refImg0: int16
   :param ops: requires 'smooth_sigma'
               (if ```ops['1Preg']```, need 'spatial_taper', 'spatial_hp', 'pre_smooth')
   :type ops: dictionary

   :returns: * **maskMul** (*float32*) -- mask that is multiplied to spatially taper frames
             * **maskOffset** (*float32*) -- shifts in x from cfRefImg to data for each frame
             * **cfRefImg** (*complex64*) -- reference image fft'ed and complex conjugate and multiplied by gaussian
               filter in the fft domain with standard deviation 'smooth_sigma'


.. function:: shift_data(X, ymax, xmax)

   rigid shift X by integer shifts ymax and xmax in place (no return)

   :param X: array that's frames x Ly x Lx
   :type X: int16
   :param ymax: shifts in y from cfRefImg to data for each frame
   :type ymax: int
   :param xmax: shifts in x from cfRefImg to data for each frame
   :type xmax: int


.. function:: addmultiplytype(x, y, z)


.. function:: apply_dotnorm(Y, cfRefImg)


.. function:: phasecorr(data, refAndMasks, ops)

   compute registration offsets


.. function:: my_clip(X, lcorr)

   perform 2D fftshift and crop with lcorr


.. function:: phasecorr_cpu(data, refAndMasks, lcorr)

   compute phase correlation between data and reference image

   :param data: array that's frames x Ly x Lx
   :type data: int16
   :param refAndMasks: maskMul, maskOffset and cfRefImg (from prepare_refAndMasks)
   :type refAndMasks: list
   :param lcorr: maximum shift in pixels
   :type lcorr: int

   :returns: * **ymax** (*int*) -- shifts in y from cfRefImg to data for each frame
             * **xmax** (*int*) -- shifts in x from cfRefImg to data for each frame
             * **cmax** (*float*) -- maximum of phase correlation for each frame


.. function:: register_and_shift(data, refAndMasks, ops)

   register data matrix to reference image and shift

   need to run ```refAndMasks = register.prepare_refAndMasks(ops)``` to get fft'ed masks;
   if ```ops['nonrigid']``` need to run ```ops = utils.make_blocks(ops)```

   :param data: array that's frames x Ly x Lx
   :type data: int16
   :param refAndMasks: maskMul, maskOffset and cfRefImg (from prepare_refAndMasks)
   :type refAndMasks: list
   :param ops: requires 'nonrigid', 'bidiphase', '1Preg'
   :type ops: dictionary

   :returns: * **data** (*int16*) -- registered frames x Ly x Lx
             * **ymax** (*int*) -- shifts in y from cfRefImg to data for each frame
             * **xmax** (*int*) -- shifts in x from cfRefImg to data for each frame
             * **cmax** (*float*) -- maximum of phase correlation for each frame
             * **yxnr** (*list*) -- ymax, xmax and cmax from the non-rigid registration


.. function:: get_nFrames(ops)

   get number of frames in binary file

   :param ops: requires 'Ly', 'Lx', 'reg_file' (optional 'keep_movie_raw' and 'raw_file')
   :type ops: dictionary

   :returns: **nFrames** -- number of frames in the binary
   :rtype: int


.. function:: subsample_frames(ops, nsamps)

   get nsamps frames from binary file for initial reference image

   :param ops: requires 'Ly', 'Lx', 'nframes', 'reg_file' (optional 'keep_movie_raw' and 'raw_file')
   :type ops: dictionary
   :param nsamps: number of frames to return
   :type nsamps: int

   :returns: **frames** -- frames x Ly x Lx
   :rtype: int16


.. function:: get_bidiphase(frames)

   computes the bidirectional phase offset

   sometimes in line scanning there will be offsets between lines;
   if ops['do_bidiphase'], then bidiphase is computed and applied

   :param frames: random subsample of frames in binary (frames x Ly x Lx)
   :type frames: int16

   :returns: **bidiphase** -- bidirectional phase offset in pixels
   :rtype: int


.. function:: shift_bidiphase(frames, bidiphase)

   shift frames by bidirectional phase offset, bidiphase

   sometimes in line scanning there will be offsets between lines;
   shifts last axis by bidiphase

   :param frames: frames from binary (frames x Ly x Lx)
   :type frames: int16
   :param bidiphase: bidirectional phase offset in pixels
   :type bidiphase: int

   :returns: **frames** -- shifted frames from binary (frames x Ly x Lx)
   :rtype: int16


.. function:: pick_initial_reference(frames)

   computes the initial reference image

   the seed frame is the frame with the largest correlations with other frames;
   the average of the seed frame with its top 20 correlated pairs is the
   inital reference frame returned

   :param frames: frames from binary (frames x Ly x Lx)
   :type frames: int16

   :returns: **refImg** -- initial reference image (Ly x Lx)
   :rtype: int16


.. function:: iterative_alignment(ops, frames, refImg)

   iterative alignment of initial frames to compute reference image

   the seed frame is the frame with the largest correlations with other frames;
   the average of the seed frame with its top 20 correlated pairs is the
   inital reference frame returned

   :param ops: requires 'nonrigid', 'smooth_sigma', 'bidiphase', '1Preg'
   :type ops: dictionary
   :param frames: frames from binary (frames x Ly x Lx)
   :type frames: int16
   :param refImg: initial reference image (Ly x Lx)
   :type refImg: int16

   :returns: **refImg** -- final reference image (Ly x Lx)
   :rtype: int16


.. function:: compute_reference_image(ops)

   compute the reference image

   computes initial reference image using ops['nimg_init'] frames

   :param ops: requires 'nimg_init', 'nonrigid', 'smooth_sigma', 'bidiphase', '1Preg',
               'reg_file', (optional 'keep_movie_raw', 'raw_movie')
   :type ops: dictionary

   :returns: **refImg** -- initial reference image (Ly x Lx)
   :rtype: int16


.. function:: prepare_refAndMasks(refImg, ops)

   prepares refAndMasks for phasecorr using refImg

   :param refImg: reference image
   :type refImg: int16
   :param ops: requires 'smooth_sigma'
               (if ```ops['1Preg']```, need 'spatial_taper', 'spatial_hp', 'pre_smooth')
   :type ops: dictionary

   :returns: **refAndMasks** -- maskMul, maskOffset, cfRefImg (see register.prepare_masks for details)
   :rtype: list


.. function:: init_offsets(ops)

   initialize offsets for all frames


.. function:: compute_crop(ops)

   determines ops['badframes'] (using ops['th_badframes'])
   and excludes these ops['badframes'] when computing valid ranges
   from registration in y and x


.. function:: write_tiffs(data, ops, k, ichan)

   writes frames to tiffs

   :param data: frames x Ly x Lx
   :type data: int16
   :param ops: requires 'functional_chan', 'align_by_chan'
   :type ops: dictionary
   :param k: number of tiff
   :type k: int


.. function:: bin_paths(ops, raw)

   set which binary is being aligned to


.. function:: register_binary_to_ref(ops, refImg, reg_file_align, raw_file_align)

   register binary data to reference image refImg

   :param ops:
   :type ops: dictionary
   :param refImg: reference image
   :type refImg: int16
   :param reg_file_align: file to (read if raw_file_align empty, and) write registered binary to
   :type reg_file_align: string
   :param raw_file_align: file to read raw binary from (if not empty)
   :type raw_file_align: string

   :returns: * **ops** (*dictionary*) -- sets 'meanImg' or 'meanImg_chan2'
               maskMul, maskOffset, cfRefImg (see register.prepare_masks for details)
             * **offsets** (*list*) -- [ymax, xmax, cmax, yxnr] <- shifts and correlations


.. function:: apply_shifts(data, ops, ymax, xmax, ymax1, xmax1)

   apply rigid and nonrigid shifts to data (for chan that's not 'align_by_chan')

   :param data:
   :type data: int16

   ops : dictionary

   refImg : int16
       reference image

   reg_file_align : string
       file to (read if raw_file_align empty, and) write registered binary to

   raw_file_align : string
       file to read raw binary from (if not empty)

   :returns: * **ops** (*dictionary*) -- sets 'meanImg' or 'meanImg_chan2'
               maskMul, maskOffset, cfRefImg (see register.prepare_masks for details)
             * **offsets** (*list*) -- [ymax, xmax, cmax, yxnr] <- shifts and correlations


.. function:: apply_shifts_to_binary(ops, offsets, reg_file_alt, raw_file_alt)

   apply registration shifts to binary data


.. function:: register_binary(ops, refImg=None)

   registration of binary files


.. function:: register_npy(Z, ops)


.. function:: shift_data_subpixel(inputs)

   rigid shift of X by ymax and xmax


