:mod:`suite2p.utils`
====================

.. py:module:: suite2p.utils


Module Contents
---------------

.. function:: tic()


.. function:: toc(i0)


.. function:: fitMVGaus(y, x, lam, thres=2.5)

   computes 2D gaussian fit to data and returns ellipse of radius thres standard deviations.

   :param y: pixel locations in y
   :type y: float, array
   :param x: pixel locations in x
   :type x: float, array
   :param lam: weights of each pixel
   :type lam: float, array

   :returns: * **mu** (*float*) -- mean of gaussian fit.
             * **cov** (*float*) -- covariance of gaussian fit.
             * **radii** (*float, array*) -- half of major and minor axis lengths of elliptical fit.
             * **ellipse** (*float, array*) -- coordinates of elliptical fit.
             * **area** (*float*) -- area of ellipse.


.. function:: enhanced_mean_image(ops)

   computes enhanced mean image and adds it to ops

   Median filters ops['meanImg'] with 4*diameter in 2D and subtracts and
   divides by this median-filtered image to return a high-pass filtered
   image ops['meanImgE']

   :param ops: uses 'meanImg', 'aspect', 'diameter', 'yrange' and 'xrange'
   :type ops: dictionary

   :returns: **ops** -- 'meanImgE' field added
   :rtype: dictionary


.. function:: init_ops(ops)

   initializes ops files for each plane in recording

   :param ops: 'nplanes', 'save_path', 'save_folder', 'fast_disk', 'nchannels', 'keep_movie_raw'
               + (if mesoscope) 'dy', 'dx', 'lines'
   :type ops: dictionary

   :returns: **ops1** -- adds fields 'save_path0', 'reg_file'
             (depending on ops: 'raw_file', 'reg_file_chan2', 'raw_file_chan2')
   :rtype: list of dictionaries


.. function:: list_h5(ops)


.. function:: find_files_open_binaries(ops1, ish5)

   finds tiffs or h5 files and opens binaries for writing

   :param ops1: 'keep_movie_raw', 'data_path', 'look_one_level_down', 'reg_file'...
   :type ops1: list of dictionaries

   :returns: **ops1** -- adds fields 'filelist', 'first_tiffs', opens binaries
   :rtype: list of dictionaries


.. function:: h5py_to_binary(ops)

   finds h5 files and writes them to binaries

   :param ops: 'nplanes', 'h5_path', 'h5_key', 'save_path', 'save_folder', 'fast_disk',
               'nchannels', 'keep_movie_raw', 'look_one_level_down'
   :type ops: dictionary

   :returns: **ops1** -- 'Ly', 'Lx', ops1[j]['reg_file'] or ops1[j]['raw_file'] is created binary
   :rtype: list of dictionaries


.. function:: open_tiff(file, sktiff)

   opens tiff with either ScanImageTiffReader or skimage
   returns tiff and its length


.. function:: choose_tiff_reader(fs0, ops)

   chooses tiff reader (ScanImageTiffReader is default)

   tries to open tiff with ScanImageTiffReader and if it fails sets sktiff to True

   :param fs0: path to first tiff in list
   :type fs0: string
   :param ops: 'batch_size'
   :type ops: dictionary

   :returns: **sktiff** -- whether or not to use scikit-image tiff reader
   :rtype: bool


.. function:: tiff_to_binary(ops)

   finds tiff files and writes them to binaries

   :param ops: 'nplanes', 'data_path', 'save_path', 'save_folder', 'fast_disk', 'nchannels', 'keep_movie_raw', 'look_one_level_down'
   :type ops: dictionary

   :returns: **ops1** -- ops1[j]['reg_file'] or ops1[j]['raw_file'] is created binary
             assigns keys 'Ly', 'Lx', 'tiffreader', 'first_tiffs',
             'frames_per_folder', 'nframes', 'meanImg', 'meanImg_chan2'
   :rtype: list of dictionaries


.. function:: mesoscan_to_binary(ops)

   finds mesoscope tiff files and writes them to binaries

   :param ops: 'nplanes', 'data_path', 'save_path', 'save_folder', 'fast_disk',
               'nchannels', 'keep_movie_raw', 'look_one_level_down', 'lines', 'dx', 'dy'
   :type ops: dictionary

   :returns: **ops1** -- ops1[j]['reg_file'] or ops1[j]['raw_file'] is created binary
             assigns keys 'Ly', 'Lx', 'tiffreader', 'first_tiffs', 'frames_per_folder',
             'nframes', 'meanImg', 'meanImg_chan2'
   :rtype: list of dictionaries


.. function:: list_tifs(froot, look_one_level_down)

   get list of tiffs in folder froot + one level down maybe


.. function:: get_tif_list(ops)

   make list of tiffs to process
   if ops['subfolders'], then all tiffs ops['data_path'][0] / ops['subfolders'] / *.tif
   if ops['look_one_level_down'], then all tiffs in all folders + one level down
   if ops['tiff_list'], then ops['data_path'][0] / ops['tiff_list'] ONLY


.. function:: sub2ind(array_shape, rows, cols)


.. function:: combined(ops1)

   Combines all the entries in ops1 into a single result file.

   Multi-plane recordings are arranged to best tile a square.
   Multi-roi recordings are arranged by their dx,dy physical localization.


.. function:: make_blocks(ops)

   computes overlapping blocks to split FOV into to register separately

   :param ops: 'Ly', 'Lx' (optional 'block_size')
   :type ops: dictionary

   :returns: **ops** -- 'yblock', 'xblock', 'nblocks', 'NRsm'
   :rtype: dictionary


.. function:: sample_frames(ops, ix, reg_file, crop=True)

   get frames ix from reg_file
   frames are cropped by ops['yrange'] and ops['xrange']


.. function:: ome_to_binary(ops)

   converts ome.tiff to *.bin file for non-interleaved red channel recordings
   assumes SINGLE-PAGE tiffs where first channel has string 'Ch1'
   and also SINGLE FOLDER

   :param ops: keys nplanes, nchannels, data_path, look_one_level_down, reg_file
   :type ops: dictionary

   :returns: **ops1** -- creates binaries ops1[j]['reg_file']
             assigns keys: tiffreader, first_tiffs, frames_per_folder, nframes, meanImg, meanImg_chan2
   :rtype: list of dictionaries


