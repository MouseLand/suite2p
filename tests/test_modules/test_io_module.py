"""
Tests for the Suite2p IO module
"""

import numpy as np
from pathlib import Path
from tifffile import imread
from suite2p import io
from pytest import fixture


def get_binary_file_data(op):
    # Read in binary file's contents as int16 np array
    binary_file_data = np.fromfile(
        str(Path(op['save_path0']).joinpath('suite2p', 'plane0', 'data.bin')),
        np.int16
    )
    return np.reshape(binary_file_data, (-1, op['Ly'], op['Lx']))


@fixture()
def binfile1500(test_ops):
    test_ops['tiff_list'] = ['input_1500.tif']
    op = io.tiff_to_binary(test_ops)[0]
    bin_filename = str(Path(op['save_path0']).joinpath('suite2p', 'plane0', 'data.bin'))
    with io.BinaryFile(Ly=op['Ly'], Lx=op['Lx'], read_filename=bin_filename) as bin_file:
        yield bin_file


def test_tiff_reconstruction_from_binary_file(test_ops):
    """
    Tests to see if tif generated by tiff_to_binary and write_tiff matches test tif.
    """
    test_ops['tiff_list'] = ['input.tif']
    op = io.tiff_to_binary(test_ops)[0]
    output_data = get_binary_file_data(op)
    # Make sure data in matrix is nonnegative
    assert np.all(output_data >= 0)
    fname = io.generate_tiff_filename(
        functional_chan=op['functional_chan'],
        align_by_chan=op['align_by_chan'],
        save_path=op['save_path'],
        k=0,
        ichan=True
    )
    io.save_tiff(output_data, fname=fname)
    reconstructed_tiff_data = imread(
        str(Path(test_ops['save_path0']).joinpath('suite2p', 'plane0', 'reg_tif', 'file000_chan0.tif'))
    )
    # Compare to our test data
    prior_data = imread(
        str(Path(test_ops['data_path'][0]).joinpath('1plane1chan', 'suite2p', 'test_write_tiff.tif'))
    )
    assert np.array_equal(reconstructed_tiff_data, prior_data)


def test_h5_to_binary_produces_nonnegative_output_data(test_ops):
    test_ops['h5py'] = Path(test_ops['data_path'][0]).joinpath('input.h5')
    test_ops['data_path'] = []
    op = io.h5py_to_binary(test_ops)[0]
    output_data = get_binary_file_data(op)
    assert np.all(output_data >= 0)


def test_that_BinaryFile_class_counts_frames_correctly(binfile1500):
    assert binfile1500.n_frames == 1500


def test_that_bin_movie_without_badframes_results_in_a_same_size_array(binfile1500):
    Ly, Lx = binfile1500.Ly, binfile1500.Lx
    mov = io.binary.bin_movie(filename=binfile1500.read_filename, Ly=Ly, Lx=Lx, bin_size=1)
    assert mov.shape == (1500, Ly, Lx)


def test_that_bin_movie_with_badframes_results_in_a_smaller_array(binfile1500):

    np.random.seed(42)
    bad_frames = np.random.randint(2, size=binfile1500.n_frames, dtype=bool)

    Ly, Lx = binfile1500.Ly, binfile1500.Lx
    mov = io.binary.bin_movie(
        filename=binfile1500.read_filename,
        Ly=Ly, Lx=Lx, bin_size=1, bad_frames=bad_frames,
        reject_threshold=0  # reject_threshold can produce an unpredictable number of frames
    )
    assert len(mov) < binfile1500.n_frames, "bin_movie didn't produce a smaller array."
    assert len(mov) == len(bad_frames) - sum(bad_frames), "bin_movie didn't produce the right size array."
